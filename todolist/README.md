# Assignment 4 Essay

https://pbd22-assignment2.herokuapp.com/todolist <br>

## What does {% csrf_token %} do in the <form> element? What happens if there is no such "code snippet" in the <form> element? 
A CSRF (Cross-Site Request Forgery) token is a tag that Django has implemented to prevent a CSRF attack, which is when an attacker induces users to perform actions that they do not intend to perform. This happens when the user is in a session in a certain Web application, and by doing something unaware (e.g. clicking a malicious URL), a request gets crafted and sent into the Web application without the user's consent. Since the application cannot differentiate if the request is actually made by the user or otherwise, the unauthorized request gets executed.  <br>
The tag solves this issue by generating a token on the server side when rendering a page, and cross-checks this token for any requests that come back in. If a request doesn't contain the generated token, then the request does not get executed. <br>
Without this code snippet or tag, then our application would be vulnurable to CSRF attacks, and might be liable for a breach of personal data, unsanctioned transactions, or other unsavory events. <br>
  
## Can we create the <form> element manually (without using a generator like {{ form.as_table }})? Explain generally how to create <form> manually.
It is possible to generate a form manually. The generator {{ form.as_table }} uses a python file that contains a form object as reference to display onto an HTML file, but it is also possible to directly create a form on the HTML file itself. <br>
You would generally use the form tag, followed by an attribute "method" which has a value of between "POST" and "GET". The main difference between the two is that GET carries request parameter appended in URL string while POST carries request parameter in message body. Then, you would use the input tag, along with its various attributes to give a slot where the user can input their data into the form. Additionally, you could use the label tag to specify what is expected on each input. A few frequently used examples of input types would be: radio, checkbox, text, button, date, email, file, and URL. <br>

## Describe the data flow process from the submission made by the user through the HTML form, data storage in the database, until the appearance of the data that has been stored in the HTML template.
When the user clicks the Submit button on the Create a Task page, views.py will execute the function create_task which accepts a request as a parameter. The request would be a form submission, hence its method could be checked to validate that it is a form submission. After validating that it is indeed a form submission, it then assigns a variable "form" to a form object TaskForm with data defined by the form submission request. <br>
Then, the form's validity will be checked. Given that it is valid, the form itself will be saved onto the database but not yet committed. This form will be temporarily assigned to a variable "task". This is done so that the user that submitted the form could be kept track of. "task"'s field called "task_user" (which defines what user submitted the form) will be assigned to the request's user (the user that made the request). At long last, the form can be committed into the database via saving and committing "task". <br>
After saving the form submission into the database, the app directs the user back to the main todolist page. At the moment the user submits the form and gets redirected, the database would have been updated already. This would be reflected on the todolist page itself, since the function show_todolist would update the HTML code found in the templates folder to include the newly created task into the table. <br>
However, in the case where the request is not a form submission, the function would simply define form as an empty TaskForm object so that it could be passed into the Create a Task page template and displayed. This is done using the render function, along with a context containing said form. <br>

## Explain how you implement the checklist above.
First, I created the app using the "python manage.py startapp todolist" command. Then, the "todolist" folder appeared on the application folder. AFter that, I added "todolist" as an installed app in the django project's settings. The same was also done in the django project's urls so it could be accessed via http://localhost:8000/todolist. <br>
Moving on, I created a model called ToDoTask on the file models.py. ToDoTask had fields task_user (the user that created the task), task_date (when the task was made), task_title (the task's title), and task_description (what the task demands). task_user was made using a foreign key with a parameter of the User model from django.contrib.auth.models. task_date was made using the datetime module. Finally, task_title and task_description would be added later on when the user fills out the task creation form. <br>
I then created the register, login and logout functions on views.py, and along with that, the register, login and home page HTML files as the templates. The register function would use the UserCreationForm that is already included in django to detect a form submission, save the form, and commit it to the database. The login function would use the users included in the database to authorize whether the user's credentials are recorded. This is done using the request variable and the authorize function. The login function also includes a cookie that is generated at the time when the login is successful and the user is redirected. The cookie will display the time of the user's login. Finally, the logout function (referenced by a hyperlink button in the hompage file) will redirect the user back to the login page and deletes the generated cookie. <br>
The todolist homepage includes a table that displays tasks (their creation dates, titles, and descriptions). There is also 2 buttons: one will redirect to the Create a Task page, and the other logs the user out of the application. The register page contains a form that will request a username, and a password (along with password verification). The login page will request a username and password, and will reject the authorization if said username or password is not recorded. <br>
The task creation page is created using a template called create_task.html, a file called form.py that contains a ModelForm object based on the model ToDoTask (containing fields task_title and task_description), and a function in views.py called create_task. The forms.py file will be referenced in both the template and the function. The template's purpose is just to display the form using {{ form.as_table }}. The function will (1) display the HTML file along with the attached form, (2) validate the form submission, (3) add the form (without the user that sent it in), (4) commit a form submission with the user sent in to the database, and (5) redirect the user back to the homepage. <br>
After that, I modified the urls.py file to include all routings to all pages added into the project, which includes homepage, login, logout, register, and Create a Task pages/mechanisms. After all routings were done, I manually created 2 dummy users and 3 tasks (2 on kaloosh.falito and 1 on dummy1) using http://localhost:8000/todolist. Then, I used the command "python manage.py dumpdata auth.user > user.json" and "python manage.py dumpdata todolist.ToDoTask > todolist.json" to create fixture files that will be loaded at the time up uploadng into Heroku. After relocating the newly generated files into a fixtures file in the todolist application, I edited the Procfile to include the command "python manage.py loaddata user.json" and "python manage.py loaddata todolist.json". <br>
Finally, I git added, committed, and pushed into the github repository, and the Procfile automatically uploaded the application onto Heroku.
